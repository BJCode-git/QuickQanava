{
    "docs": [
        {
            "location": "/index.html", 
            "text": "(Linux/g++5/Qt5.8 - OSX/Clang/Qt5.9)\n\n\n (Windows MSVC 2015 x64/Qt5.9)\n\n\n\n\n\n\n\n\n\n\nQuickQanava is alpha, interface may change before 1.0.0 release, but QuickQanava is already used extensively in production code.\n\n\n\n\n\n\nQuickQanava is licensed under BSD-3, support is available on demand: \n\n\n\n\nQuickQanava\n is a C++14 library designed to display graphs and relational content in a QtQuick application. QuickQanava provide QML components and C++ classes to visualize medium-sized directed graphs in a C++/QML application. QuickQanava does not provide advanced layout algorithms, but rather focus on displaying relational content in advanced dynamic user interfaces (with DnD support, resizable content, visual connection of nodes).\n\n\nQuickQanava main repository is hosted on GitHub: \nhttps://github.com/cneben/quickqanava\n\n\nQuickQanava is primarily developed with Qt \n= 5.10 with MSVC2015 and g++5.4. Since 0.9.2, minimal required Qt version is \nQt 5.10\n.\n\n\n\n\nProject homepage: \nhttp://www.destrat.io/quickqanava\n\n\nReference documentation: \nhttp://www.destrat.io/qanava/doc/index.html\n\n\n\n\nPlease refer to \nInstallation\n subsection and \nQuickstart guide\n for more information about installing and using QuickQanava.\n\n\nGallery\n\n\nQuickQanava samples\n\n\n\n\n\n\n\n\nNode Grouping\n\n\nVisual Connection of Nodes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRoadmap\n\n\n\n\nv0.9.4:\n  \n\n\nQuickContainers (Qt/QML observable adapter for STL or Qt containers):\n\n\n Redesign QuickContainers: qcm::ContainerModel\n memory footprint is too high (inheritance from QAbstractItemModel comes with a strong virtual and signals/slots overhead)\n\n\n Add support for standard library containers.\n\n\n Increase test coverage.\n\n\n\n\n\n\n Fix port remove issues.\n\n\n Add full CMake support..    \n\n\n\n\n\n\nv0.9.5:\n\n\n Add support for direct visual dragging of port items.\n\n\n Add full support for groups inside group (ie subgraphs).\n\n\n Fix current qan::PointGrid bugs and add \"snap to grid\" support.\n\n\n\n\n\n\nv1.0.0: Advanced edge visualization\n  \n\n\nGTpo (Configurable topology library):\n\n\n Push test coverage to 100% (ie increase coverage for subgroups).- [80%] Redesign qan::Graph interface for creating content.\n\n\n Publish the 4k sample (40k is probably too much for QML without dedicated culling and LOD code).", 
            "title": "QuickQanava"
        }, 
        {
            "location": "/index.html#gallery", 
            "text": "QuickQanava samples     Node Grouping  Visual Connection of Nodes", 
            "title": "Gallery"
        }, 
        {
            "location": "/index.html#roadmap", 
            "text": "v0.9.4:     QuickContainers (Qt/QML observable adapter for STL or Qt containers):   Redesign QuickContainers: qcm::ContainerModel  memory footprint is too high (inheritance from QAbstractItemModel comes with a strong virtual and signals/slots overhead)   Add support for standard library containers.   Increase test coverage.     Fix port remove issues.   Add full CMake support..        v0.9.5:   Add support for direct visual dragging of port items.   Add full support for groups inside group (ie subgraphs).   Fix current qan::PointGrid bugs and add \"snap to grid\" support.    v1.0.0: Advanced edge visualization     GTpo (Configurable topology library):   Push test coverage to 100% (ie increase coverage for subgroups).- [80%] Redesign qan::Graph interface for creating content.   Publish the 4k sample (40k is probably too much for QML without dedicated culling and LOD code).", 
            "title": "Roadmap"
        }, 
        {
            "location": "/installation/index.html", 
            "text": "QuickQanava Quick Start\n\n\nDependencies\n\n\n\n\n\n\n\n\nDependency\n\n\nMandatory\n\n\nIncluded in source tree\n\n\nLicence\n\n\n\n\n\n\n\n\n\n\nGTpo\n\n\nYes\n\n\nYes\n (GIT submodule)\n\n\n MIT\n\n\n\n\n\n\nGoogle Test/Mock\n\n\nNo\n\n\nNo\n\n\nPermissive\n\n\n\n\n\n\n\n\n\n\nGoogle Test\n is a \nGTpo\n dependency, it is optional for QuickQanava until your intention is to use a graph with custom non-STL/non-Qt containers: \n\n\n\n\nBuilding from sources\n\n\nGet the latest QuickQanava sources:\n\n\n1\n2\ngit clone https://github.com/cneben/QuickQanava\n\ncd\n QuickQanava\n\n\n\n\n\n\nQuickQanava use \nqmake\n as its main build configuration system.\n\n\n\n\n\n\nOpen \nquickqanava.pro\n in QtCreator\n\n\n\n\n\n\nSelect a kit, build and launch samples.\n\n\n\n\n\n\nUsing from external projects\n\n\nThe recommended way of using QuickQanava is to include the library directly as a GIT submodule in your project:\n\n\n1\n2\n3\n# Install QuickQanava as a GIT submodule\n\n$ git submodule add https://github.com/cneben/QuickQanava\n\n git submodule update\n\n\n\n\n\n\nOnce GIT has finished downloading, QuickQanava and its dependencies (\nGTpo\n) projects files could be included directly in your main qmake .pro file with the following two #include statements:\n\n\n1\n2\n#in your project main .pro qmake configuration file\n\ninclude\n(\n$$\nPWD/QuickQanava/src/quickqanava.pri\n)", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/index.html#quickqanava-quick-start", 
            "text": "", 
            "title": "QuickQanava Quick Start"
        }, 
        {
            "location": "/installation/index.html#dependencies", 
            "text": "Dependency  Mandatory  Included in source tree  Licence      GTpo  Yes  Yes  (GIT submodule)   MIT    Google Test/Mock  No  No  Permissive      Google Test  is a  GTpo  dependency, it is optional for QuickQanava until your intention is to use a graph with custom non-STL/non-Qt containers:", 
            "title": "Dependencies"
        }, 
        {
            "location": "/installation/index.html#building-from-sources", 
            "text": "Get the latest QuickQanava sources:  1\n2 git clone https://github.com/cneben/QuickQanava cd  QuickQanava   QuickQanava use  qmake  as its main build configuration system.    Open  quickqanava.pro  in QtCreator    Select a kit, build and launch samples.", 
            "title": "Building from sources"
        }, 
        {
            "location": "/installation/index.html#using-from-external-projects", 
            "text": "The recommended way of using QuickQanava is to include the library directly as a GIT submodule in your project:  1\n2\n3 # Install QuickQanava as a GIT submodule \n$ git submodule add https://github.com/cneben/QuickQanava  git submodule update   Once GIT has finished downloading, QuickQanava and its dependencies ( GTpo ) projects files could be included directly in your main qmake .pro file with the following two #include statements:  1\n2 #in your project main .pro qmake configuration file \ninclude ( $$ PWD/QuickQanava/src/quickqanava.pri )", 
            "title": "Using from external projects"
        }, 
        {
            "location": "/topology/index.html", 
            "text": "Creating Topology\n\n\nBuilding a Simple Directed Graph\n\n\nQuickQanava should be initialized in your c++ main function:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n#include\n \nQuickQanava\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[])\n\n\n{\n\n    \nQGuiApplication\n \napp\n(\nargc\n,\n \nargv\n);\n\n    \nQQuickStyle\n::\nsetStyle\n(\nMaterial\n);\n\n    \nQQmlApplicationEngine\n \nengine\n;\n\n    \n// Or in a custom QQuickView constructor:\n\n\n    \nQuickQanava\n::\ninitialize\n();\n\n\n    \nengine\n.\nload\n(\n \n...\n \n);\n\n    \nreturn\n \napp\n.\nexec\n();\n\n\n}\n\n\n\n\n\n\n\nThen, in QML import QuickQanava:\n\n1\n2\nimport\n \nQuickQanava\n \n2.0\n \nas\n \nQan\n\n\nimport\n \nqrc:/QuickQanava\n \nas\n \nQan\n\n\n\n\n\n\nAnd create a \nQan.Graph\n component:\n\n1\n2\n3\n4\n5\n6\n7\n8\nQan\n.\nGraph\n \n{\n\n    \nid\n:\n \ngraph\n\n    \nanchors\n.\nfill\n:\n \nparent\n\n    \nComponent\n.\nonCompleted\n:\n \n{\n\n        \nvar\n \nn1\n \n=\n \ngraph\n.\ninsertNode\n()\n\n        \nn1\n.\nlabel\n \n=\n \nHello World\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTopology\n\n\nAdding content\n\n\nContent could initialized in graph \nonCompleted()\n function:\n\n\n\n\nQan\n.\nNode\n \nQan\n.\nGraph\n.\ninsertNode\n()\n: \n\n\nQan\n.\nEdge\n \nQan\n.\nGraph\n.\ninsertEdge\n(\nQan\n.\nNode\n,\n \nQan\n.\nNode\n)\n:\n\n\nQan\n.\nGroup\n \nQan\n.\nGraph\n.\ninsertGroup\n()\n:\n\n\n\n\nAll primitives (nodes, edges, groups) have both a \"topological and data\" aspect (Qan.Node, Qan.Edge, Qan.Group) and a visual counter part accessible trough their \nitem\n property (usually a Qan.NodeItem, Qan.EdgeItem, Qan.GroupItem).\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nQan\n.\nGraph\n \n{\n\n    \nid\n:\n \ngraph\n\n    \nanchors\n.\nfill\n:\n \nparent\n\n    \nComponent\n.\nonCompleted\n:\n \n{\n\n\n        \nvar\n \nn1\n \n=\n \ngraph\n.\ninsertNode\n()\n\n\n        \nn1\n.\nlabel\n \n=\n \nHello World\n            \n// n1 encode node topology (it\ns a qan::Node)\n\n        \nn1\n.\nitem\n.\nx\n \n=\n \n50\n;\n \nn1\n.\nitem\n.\ny\n \n=\n \n50\n      \n// n1.item is n1 visual counterpart, usually a qan::NodeItem\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nConnections between nodes could be added from QML using Qan.Graph.insertEdge() function, or from c++ with qan::Graph::insertEdge() method. Edges graphics appearance is configured trought their \nstyle\n property, more information on available edge style option is available in \nStyles section \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nComponent\n.\nonCompleted\n:\n \n{\n    \n// Qan.Graph.Component.onCompleted()\n\n    \nvar\n \nn1\n \n=\n \ngraph\n.\ninsertNode\n()\n\n    \nn1\n.\nlabel\n \n=\n \nHello World\n;\n \nn1\n.\nitem\n.\nx\n=\n50\n;\n \nn1\n.\nitem\n.\ny\n=\n \n50\n\n    \nvar\n \nn2\n \n=\n \ngraph\n.\ninsertNode\n()\n\n    \nn2\n.\nlabel\n \n=\n \nNode 2\n;\n \nn2\n.\nitem\n.\nx\n=\n200\n;\n \nn2\n.\nitem\n.\ny\n=\n \n125\n\n\n\n    \nvar\n \ne\n \n=\n \ngraph\n.\ninsertEdge\n(\nn1\n,\n \nn2\n);\n\n\n    \ndefaultEdgeStyle\n.\nlineType\n \n=\n \nQan\n.\nEdgeStyle\n.\nCurved\n\n\n}\n\n\n\n\n\n\n\n\n\nNode and edges appearance could be tuned by changing default styles properties directly from QML with global variables \ndefaultEdgeStyle\n and \ndefaultNodeStyle\n, see the \nStyle Management\n section for more options.\n\n\nDocks and ports could be used to control how an edge is connected to source and destination node:\n\n\n\n\nA dock \nQan.DockItem\n is a visual group of ports. QuickQanava define 4 ports identified by their position: Qan.NodeItem.Left / Qan.NodeItem.Top / Qan.NodeItem.Right / Qan.NodeItem.Bottom.\n\n\nA port \nQan.PortItem\n is a graphical item attached to a node in a specific port that could receive in edge or \"emit\" out edges. A dock can have multiple ports with port.type beeing either PortItem.In (only input edge), PortItem.Out (only out edge) or PortItem.InOut.\n\n\n\n\nDocks and ports are managed trought the Qan.Graph interface:\n\n\n\n\nQan\n.\nGraph\n.\ninsertPort\n(\nnode\n,\n \norientation\n)\n:  Insert a port on \nnode\n at a given \norientation\n and return a \nQan.PortItem\n.\n\n\nQan\n.\nGraph\n.\nbindEdgeDestination\n(\nedge\n,\n \nport\n)\n: Bind an \nedge\n destination on a given \nport\n.\n\n\nQan\n.\nGraph\n.\nbindEdgeSource\n(\nedge\n,\n \nport\n)\n: Bind an \nedge\n source on a given \nport\n.\n\n\n\n\nExample of port insertion and binding to existing edges:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nComponent\n.\nonCompleted\n:\n \n{\n    \n// Qan.Graph.Component.onCompleted()\n\n    \nvar\n \nn3\n \n=\n \ngraph\n.\ninsertNode\n()\n\n    \nn3\n.\nlabel\n \n=\n \nN3\n;\n \nn3\n.\nitem\n.\nx\n \n=\n \n500\n;\n \nn3\n.\nitem\n.\ny\n \n=\n \n100\n\n    \nvar\n \nn3p1\n \n=\n \ngraph\n.\ninsertInPort\n(\nn3\n,\n \nQan\n.\nNodeItem\n.\nLeft\n);\n\n    \nn3p1\n.\nlabel\n \n=\n \nIN #1\n\n\n\n    \nvar\n \nn3p1\n \n=\n \ngraph\n.\ninsertInPort\n(\nn3\n,\n \nQan\n.\nNodeItem\n.\nTop\n);\n\n\n    \nn3p1\n.\nlabel\n \n=\n \nOUT #1\n\n    \nvar\n \nn3p2\n \n=\n \ngraph\n.\ninsertInPort\n(\nn3\n,\n \nQan\n.\nNodeItem\n.\nBottom\n);\n\n    \nn3p2\n.\nlabel\n \n=\n \nOUT #2\n\n\n    \nvar\n \ne\n \n=\n \ngraph\n.\ninsertEdge\n(\nn2\n,\n \nn3\n)\n\n    \ngraph\n.\nbindEdgeDestination\n(\ne\n,\n \nn2p3\n)\n  \n// Bind our edge source to node N2 port P3 (OUT #1)\n\n    \ngraph\n.\nbindEdgeDestination\n(\ne\n,\n \nn3p1\n)\n  \n// Bind our edge destination to node N3 port P1 (IN #1)\n\n\n}\n\n\n\n\n\n\n\n(Note: Port/Dock API is still subject to change after v0.9.2)\n\n\n\n\nDocks could be fully customized using QML delegates and custom node items, refer to \ncustomdocks.qml\n example in connector sample.\n\n\nNavigation\n\n\nA graph is not \"navigable\" by default, to allow navigation using mouse panning and zooming, \nQan.Graph\n component must be defined in the \ngraph\n property of a \nQan.GraphView\n item:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nQan\n.\nGraphView\n \n{\n\n  \nid\n:\n \ngraphView\n\n  \nanchors\n.\nfill\n:\n \nparent\n\n  \nnavigable\n   \n:\n \ntrue\n\n\n  \ngraph\n:\n \nQan\n.\nGraph\n \n{\n\n\n      \nid\n:\n \ntopology\n\n    \n}\n \n// Qan.Graph: topology\n\n\n}\n \n// Qan.GraphView\n\n\n\n\n\n\n\nNavigation could be disabled by setting the \nnavigable\n property to false (it default to true).\n\n\nVisual connection of nodes\n\n\nQuickQanava allow visual connection of node with the \nQan.VisualConnector\n component. Default visual connector is configured in \nQan.Graph\n component using the following properties:\n\n\n\n\n\n\nQan.Graph.connectorEnabled\n (bool): Set to true to enable visual connection of nodes (default to false).\n\n\n\n\n\n\nQan.Graph.connectorEdgeColor\n (color): Set the visual connector preview edge color (useful to have Light/Dark theme support, default to black).\n\n\n\n\n\n\nQan.Graph.connectorCreateDefaultEdge\n (bool, default to true): When set to false, default visual connector does not use Qan.Graph.insertEdge() to create edge, but instead emit \nconnectorRequestEdgeCreation()\n signal to allow user to create custom edge be calling a user defined method on graph (\nconnectorEdgeInserted()\n is not emitted).\n\n\n\n\n\n\nQan.Graph.setConnectorSource\n (node): Select the node that should host the current visual connector.\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nQan\n.\nGraphView\n \n{\n\n  \nid\n:\n \ngraphView\n\n  \nanchors\n.\nfill\n:\n \nparent\n\n  \ngraph\n \n:\n \nQan\n.\nGraph\n \n{\n\n\n    \nconnectorEnabled\n:\n \ntrue\n\n\n    \nconnectorEdgeInserted\n:\n \nconsole\n.\ndebug\n(\n \nEdge inserted between \n \n+\n \nsrc\n.\nlabel\n \n+\n \n and  \n \n+\n \ndst\n.\nlabel\n)\n\n    \nconnectorEdgeColor\n:\n \nviolet\n\n    \nconnectorColor\n:\n \nlightblue\n\n  \n}\n \n// Qan.Graph\n\n\n}\n \n// Qan.GraphView\n\n\n\n\n\n\n\n\n\nThe following notifications callbacks are available:\n\n\n\n\n\n\nSignal \nQan.Graph.connectorEdgeInserted(edge)\n: Emitted when the visual connector has been dragged on a destination node or edge to allow specific user configuration on created edge.\n\n\n\n\n\n\nSignal \nQan.Graph.connectorRequestEdgeCreation(src, dst)\n: Emitted when the visual connector is dragged on a target with \ncreateDefaultEdge\n set to false: allow creation of custom edge (or any other action) by the user. Example:\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nQan\n.\nGraphView\n \n{\n\n  \nid\n:\n \ngraphView\n\n  \nanchors\n.\nfill\n:\n \nparent\n\n  \ngraph\n \n:\n \nQan\n.\nGraph\n \n{\n\n    \nid\n:\n \ngraph\n\n    \nconnectorEnabled\n:\n \ntrue\n\n    \nconnectorCreateDefaultEdge\n:\n \nfalse\n\n\n    \nonConnectorRequestEdgeCreation\n:\n \n{\n \n\n      \n// Do whatever you want here, for example: graph.insertEdge(src, dst)\n\n    \n}\n\n  \n}\n \n// Qan.Graph\n\n\n}\n \n// Qan.GraphView\n\n\n\n\n\n\n\nPreventing the visual connector to be shown for specific nodes (for example to force user to use out port to create topology) is possible by setting the node item \nQan.NodeItem.connectable\n property to false (See\nqan::NodeItem::connectable` \ndocumentation\n).\n\n\nReference documentation: \nqan::Connector interface\n and \nQan.VisualConnector component\n. See also \nqan::Graph\n \"Visual Connection Management\" section.\n\n\nDefault connector component \nQan.Graph.connector\n could be replaced by a user defined \nQan.VisualConnector\n to customize connector behavior in more depth. It is possible to add multiple visuals connectors on the same node, using a connector to generate specific topologies (create edges with different concrete types) or select targets visually. Such an advanced use of custom connectors is demonstrated in 'connector' sample: \nhttps://github.com/cneben/QuickQanava/tree/master/samples/connector\n\n\n\n\nResizing\n\n\nDefault resizing behaviour could be configured in \nQan.GraphView\n using the following properties:\n\n\n\n\nresizeHandlerColor\n (color): Color of the visual drop node component (could be set to Material.accent for example)\n\n\n\n\nNode with custom delegate could be resized using the \nQan.BottomRightResizer\n component. \n\n\nSelection\n\n\nSelection can be modified at graph level just by changing the graph selection policy property \nQan.Graph.selectionPolicy\n:\n\n\n\n\nQan.AbstractGraph.NoSelection\n: Selection will be disabled in the whole graph.\n\n\nQan.AbstractGraph.SelectOnClick\n: Node are selected when clicked, multiple selection is enabled when CTRL is pressed.\n\n\nQan.AbstractGraph.SelectOnCtrlClick\n: Node are selected only if CTRL is pressed when node is clicked (multiple selection is still available).\n\n\n\n\nSelection can also be configured with the following Qan.Graph properties:\n\n\n\n\nQan.Graph.selectionColor\n / \nqan\n::\nGraph\n::\nsetSelectionColor\n()\n: Color for the node selection rectangle.\n\n\nQan.Graph.selectionWeight\n / \nqan\n::\nGraph\n::\nsetSelectionWeight\n()\n: Border width of the node selection rectangle.\n\n\nQan.Graph.selectionMargin\n / \nqan\n::\nGraph\n::\nsetSelectionMargin\n()\n: Margin between the node selection rectangle and the node content (selection weight is taken into account).\n\n\n\n\nAll theses properties could be changed dynamically.\n\n\nSelection could also be disabled at node level by setting \nQan.Node.selectable\n to false, node become unselectable even if global graph selection policy is not set to \nNoSelection\n.\n\n\nCurrent multiple selection (or single selection) is available through Qan.Graph \nselectedNodes\n property. \nselectedNodes\n is a list model, it can be used in any QML view, or iterated from C++ to read the current selection:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n// Viewing the currently selected nodes with a QML ListView:\n\n\nListView\n \n{\n\n    \nid\n:\n \nselectionListView\n\n    \nLayout\n.\nfillWidth\n:\n \ntrue\n;\n \nLayout\n.\nfillHeight\n:\n \ntrue\n\n    \nclip\n:\n \ntrue\n\n\n    \nmodel\n:\n \ngraph\n.\nselectedNodes\n      \n// \n---------\n\n\n    \nspacing\n:\n \n4\n;\n \nfocus\n:\n \ntrue\n;\n \nflickableDirection\n \n:\n \nFlickable\n.\nVerticalFlick\n\n    \nhighlightFollowsCurrentItem\n:\n \nfalse\n\n    \nhighlight\n:\n \nRectangle\n \n{\n\n        \nx\n:\n \n0\n;\n \ny\n:\n \n(\n \nselectionListView\n.\ncurrentItem\n \n!==\n \nnull\n \n?\n \nselectionListView\n.\ncurrentItem\n.\ny\n \n:\n \n0\n \n);\n\n        \nwidth\n:\n \nselectionListView\n.\nwidth\n;\n \nheight\n:\n \nselectionListView\n.\ncurrentItem\n.\nheight\n\n        \ncolor\n:\n \nlightsteelblue\n;\n \nopacity\n:\n \n0.7\n;\n \nradius\n:\n \n5\n\n    \n}\n\n    \ndelegate\n:\n \nItem\n \n{\n\n        \nid\n:\n \nselectedNodeDelegate\n\n        \nwidth\n:\n \nListView\n.\nview\n.\nwidth\n;\n \nheight\n:\n \n30\n;\n\n        \nText\n \n{\n \ntext\n:\n \nLabel: \n \n+\n \nitemData\n.\nlabel\n \n}\n       \n// \n----- itemData is a Qan.Node, node \n\n                                                        \n// label could be accessed directly\n\n        \nMouseArea\n \n{\n\n            \nanchors\n.\nfill\n:\n \nselectedNodeDelegate\n\n            \nonClicked\n:\n \n{\n \nselectedNodeDelegate\n.\nListView\n.\nview\n.\ncurrentIndex\n \n=\n \nindex\n \n}\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn C++, \nselectedNodes\n could be iterated directly, the current node should be tested to ensure it is non nullptr, since the underlining model is thread-safe and could have been modified from another thread:\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n    \nauto\n \ngraph\n \n=\n \nstd\n::\nmake_unique\nqan\n::\nGraph\n();\n\n    \nfor\n \n(\n \nauto\n \nnode\n \n:\n \ngraph\n-\ngetSelectNodes\n()\n \n)\n \n{\n\n        \nif\n \n(\n \nnode\n \n!=\n \nnullptr\n \n)\n\n            \nnode\n-\ndoWhateverYouWant\n();\n\n    \n}\n\n    \n// Or better:\n\n    \nfor\n \n(\n \nconst\n \nauto\n \nnode\n \n:\n \nqAsConst\n(\ngraph\n-\ngetSelectNodes\n())\n \n)\n \n{\n\n        \nif\n \n(\n \nnode\n \n!=\n \nnullptr\n \n)\n\n            \nnode\n-\ndoWhateverYouWantConst\n();\n\n    \n}\n\n\n\n\n\n\nExample of \nQan.AbstractGraph.SelectOnClick\n selection policy with multiple selection dragging inside a group:\n\n\n\n\nUsing Groups\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nQan\n.\nGraph\n \n{\n\n  \nid\n:\n \ngraph\n\n  \nobjectName\n:\n \ngraph\n\n  \nanchors\n.\nfill\n:\n \nparent\n\n\n  \nComponent\n.\nonCompleted\n:\n \n{\n\n    \nvar\n \nn1\n \n=\n \ngraph\n.\ninsertNode\n(\n \n)\n\n    \nn1\n.\nlabel\n \n=\n \nN1\n\n    \nvar\n \nn2\n \n=\n \ngraph\n.\ninsertNode\n(\n \n)\n\n    \nn2\n.\nlabel\n \n=\n \nN2\n\n    \nvar\n \nn3\n \n=\n \ngraph\n.\ninsertNode\n(\n \n)\n\n    \nn3\n.\nlabel\n \n=\n \nN3\n\n    \ngraph\n.\ninsertEdge\n(\n \nn1\n,\n \nn2\n \n)\n\n    \ngraph\n.\ninsertEdge\n(\n \nn2\n,\n \nn3\n \n)\n\n\n    \nvar\n \ngg\n \n=\n \ngraph\n.\ninsertGroup\n();\n\n    \ngg\n.\nlabel\n \n=\n \nGroup\n\n  \n}\n\n\n}\n \n// Qan.Graph: graph\n\n\n\n\n\n\n\nDisplaying Custom Nodes\n\n\nSee the \ncustom.qml\n file in \nnodes\n sample for more information regarding installation of specifics custom delegates for nodes and edges.\n\n\nWhen defining custom nodes with complex geometry (ie. non rectangular), there is multiple ways to take bounding shape generation into account :\n\n\n\n\n\n\nUsing the default behavior for rectangular node with \ncomplexBoundingShape\n set to false (default value), bounding shape is automatically generated on node width or height change in \ngenerateDefaultBoundingShape()\n.\n\n\n\n\n\n\nUsing dedicated code by setting \ncomplexBoundingShape\n to true and with a call to \\c setBoundingShape() from a custom onRequestUpdateBoundingShape() signal handler.\n\n\n\n\n\n\nNote that signal \nrequestUpdateBoundingShape\n won't be emitted for non complex bounding shape. Optionally, you could choose to set complexBoundingShape to false and override \ngenerateDefaultBoundingShape()\n method.", 
            "title": "Topology"
        }, 
        {
            "location": "/topology/index.html#creating-topology", 
            "text": "", 
            "title": "Creating Topology"
        }, 
        {
            "location": "/topology/index.html#building-a-simple-directed-graph", 
            "text": "QuickQanava should be initialized in your c++ main function:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 #include   QuickQanava  int   main ( int   argc ,   char   * argv [])  { \n     QGuiApplication   app ( argc ,   argv ); \n     QQuickStyle :: setStyle ( Material ); \n     QQmlApplicationEngine   engine ; \n     // Or in a custom QQuickView constructor:       QuickQanava :: initialize ();       engine . load (   ...   ); \n     return   app . exec ();  }    Then, in QML import QuickQanava: 1\n2 import   QuickQanava   2.0   as   Qan  import   qrc:/QuickQanava   as   Qan    And create a  Qan.Graph  component: 1\n2\n3\n4\n5\n6\n7\n8 Qan . Graph   { \n     id :   graph \n     anchors . fill :   parent \n     Component . onCompleted :   { \n         var   n1   =   graph . insertNode () \n         n1 . label   =   Hello World \n     }  }", 
            "title": "Building a Simple Directed Graph"
        }, 
        {
            "location": "/topology/index.html#topology", 
            "text": "", 
            "title": "Topology"
        }, 
        {
            "location": "/topology/index.html#adding-content", 
            "text": "Content could initialized in graph  onCompleted()  function:   Qan . Node   Qan . Graph . insertNode () :   Qan . Edge   Qan . Graph . insertEdge ( Qan . Node ,   Qan . Node ) :  Qan . Group   Qan . Graph . insertGroup () :   All primitives (nodes, edges, groups) have both a \"topological and data\" aspect (Qan.Node, Qan.Edge, Qan.Group) and a visual counter part accessible trough their  item  property (usually a Qan.NodeItem, Qan.EdgeItem, Qan.GroupItem).  1\n2\n3\n4\n5\n6\n7\n8\n9 Qan . Graph   { \n     id :   graph \n     anchors . fill :   parent \n     Component . onCompleted :   {           var   n1   =   graph . insertNode ()           n1 . label   =   Hello World              // n1 encode node topology (it s a qan::Node) \n         n1 . item . x   =   50 ;   n1 . item . y   =   50        // n1.item is n1 visual counterpart, usually a qan::NodeItem \n     }  }     Connections between nodes could be added from QML using Qan.Graph.insertEdge() function, or from c++ with qan::Graph::insertEdge() method. Edges graphics appearance is configured trought their  style  property, more information on available edge style option is available in  Styles section   1\n2\n3\n4\n5\n6\n7\n8\n9 Component . onCompleted :   {      // Qan.Graph.Component.onCompleted() \n     var   n1   =   graph . insertNode () \n     n1 . label   =   Hello World ;   n1 . item . x = 50 ;   n1 . item . y =   50 \n     var   n2   =   graph . insertNode () \n     n2 . label   =   Node 2 ;   n2 . item . x = 200 ;   n2 . item . y =   125       var   e   =   graph . insertEdge ( n1 ,   n2 );       defaultEdgeStyle . lineType   =   Qan . EdgeStyle . Curved  }     Node and edges appearance could be tuned by changing default styles properties directly from QML with global variables  defaultEdgeStyle  and  defaultNodeStyle , see the  Style Management  section for more options.  Docks and ports could be used to control how an edge is connected to source and destination node:   A dock  Qan.DockItem  is a visual group of ports. QuickQanava define 4 ports identified by their position: Qan.NodeItem.Left / Qan.NodeItem.Top / Qan.NodeItem.Right / Qan.NodeItem.Bottom.  A port  Qan.PortItem  is a graphical item attached to a node in a specific port that could receive in edge or \"emit\" out edges. A dock can have multiple ports with port.type beeing either PortItem.In (only input edge), PortItem.Out (only out edge) or PortItem.InOut.   Docks and ports are managed trought the Qan.Graph interface:   Qan . Graph . insertPort ( node ,   orientation ) :  Insert a port on  node  at a given  orientation  and return a  Qan.PortItem .  Qan . Graph . bindEdgeDestination ( edge ,   port ) : Bind an  edge  destination on a given  port .  Qan . Graph . bindEdgeSource ( edge ,   port ) : Bind an  edge  source on a given  port .   Example of port insertion and binding to existing edges:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 Component . onCompleted :   {      // Qan.Graph.Component.onCompleted() \n     var   n3   =   graph . insertNode () \n     n3 . label   =   N3 ;   n3 . item . x   =   500 ;   n3 . item . y   =   100 \n     var   n3p1   =   graph . insertInPort ( n3 ,   Qan . NodeItem . Left ); \n     n3p1 . label   =   IN #1       var   n3p1   =   graph . insertInPort ( n3 ,   Qan . NodeItem . Top );       n3p1 . label   =   OUT #1 \n     var   n3p2   =   graph . insertInPort ( n3 ,   Qan . NodeItem . Bottom ); \n     n3p2 . label   =   OUT #2 \n\n     var   e   =   graph . insertEdge ( n2 ,   n3 ) \n     graph . bindEdgeDestination ( e ,   n2p3 )    // Bind our edge source to node N2 port P3 (OUT #1) \n     graph . bindEdgeDestination ( e ,   n3p1 )    // Bind our edge destination to node N3 port P1 (IN #1)  }    (Note: Port/Dock API is still subject to change after v0.9.2)   Docks could be fully customized using QML delegates and custom node items, refer to  customdocks.qml  example in connector sample.", 
            "title": "Adding content"
        }, 
        {
            "location": "/topology/index.html#navigation", 
            "text": "A graph is not \"navigable\" by default, to allow navigation using mouse panning and zooming,  Qan.Graph  component must be defined in the  graph  property of a  Qan.GraphView  item:  1\n2\n3\n4\n5\n6\n7\n8 Qan . GraphView   { \n   id :   graphView \n   anchors . fill :   parent \n   navigable     :   true     graph :   Qan . Graph   {         id :   topology \n     }   // Qan.Graph: topology  }   // Qan.GraphView    Navigation could be disabled by setting the  navigable  property to false (it default to true).", 
            "title": "Navigation"
        }, 
        {
            "location": "/topology/index.html#visual-connection-of-nodes", 
            "text": "QuickQanava allow visual connection of node with the  Qan.VisualConnector  component. Default visual connector is configured in  Qan.Graph  component using the following properties:    Qan.Graph.connectorEnabled  (bool): Set to true to enable visual connection of nodes (default to false).    Qan.Graph.connectorEdgeColor  (color): Set the visual connector preview edge color (useful to have Light/Dark theme support, default to black).    Qan.Graph.connectorCreateDefaultEdge  (bool, default to true): When set to false, default visual connector does not use Qan.Graph.insertEdge() to create edge, but instead emit  connectorRequestEdgeCreation()  signal to allow user to create custom edge be calling a user defined method on graph ( connectorEdgeInserted()  is not emitted).    Qan.Graph.setConnectorSource  (node): Select the node that should host the current visual connector.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 Qan . GraphView   { \n   id :   graphView \n   anchors . fill :   parent \n   graph   :   Qan . Graph   {       connectorEnabled :   true       connectorEdgeInserted :   console . debug (   Edge inserted between    +   src . label   +    and     +   dst . label ) \n     connectorEdgeColor :   violet \n     connectorColor :   lightblue \n   }   // Qan.Graph  }   // Qan.GraphView     The following notifications callbacks are available:    Signal  Qan.Graph.connectorEdgeInserted(edge) : Emitted when the visual connector has been dragged on a destination node or edge to allow specific user configuration on created edge.    Signal  Qan.Graph.connectorRequestEdgeCreation(src, dst) : Emitted when the visual connector is dragged on a target with  createDefaultEdge  set to false: allow creation of custom edge (or any other action) by the user. Example:     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 Qan . GraphView   { \n   id :   graphView \n   anchors . fill :   parent \n   graph   :   Qan . Graph   { \n     id :   graph \n     connectorEnabled :   true \n     connectorCreateDefaultEdge :   false       onConnectorRequestEdgeCreation :   {          // Do whatever you want here, for example: graph.insertEdge(src, dst) \n     } \n   }   // Qan.Graph  }   // Qan.GraphView    Preventing the visual connector to be shown for specific nodes (for example to force user to use out port to create topology) is possible by setting the node item  Qan.NodeItem.connectable  property to false (See qan::NodeItem::connectable`  documentation ).  Reference documentation:  qan::Connector interface  and  Qan.VisualConnector component . See also  qan::Graph  \"Visual Connection Management\" section.  Default connector component  Qan.Graph.connector  could be replaced by a user defined  Qan.VisualConnector  to customize connector behavior in more depth. It is possible to add multiple visuals connectors on the same node, using a connector to generate specific topologies (create edges with different concrete types) or select targets visually. Such an advanced use of custom connectors is demonstrated in 'connector' sample:  https://github.com/cneben/QuickQanava/tree/master/samples/connector", 
            "title": "Visual connection of nodes"
        }, 
        {
            "location": "/topology/index.html#resizing", 
            "text": "Default resizing behaviour could be configured in  Qan.GraphView  using the following properties:   resizeHandlerColor  (color): Color of the visual drop node component (could be set to Material.accent for example)   Node with custom delegate could be resized using the  Qan.BottomRightResizer  component.", 
            "title": "Resizing"
        }, 
        {
            "location": "/topology/index.html#selection", 
            "text": "Selection can be modified at graph level just by changing the graph selection policy property  Qan.Graph.selectionPolicy :   Qan.AbstractGraph.NoSelection : Selection will be disabled in the whole graph.  Qan.AbstractGraph.SelectOnClick : Node are selected when clicked, multiple selection is enabled when CTRL is pressed.  Qan.AbstractGraph.SelectOnCtrlClick : Node are selected only if CTRL is pressed when node is clicked (multiple selection is still available).   Selection can also be configured with the following Qan.Graph properties:   Qan.Graph.selectionColor  /  qan :: Graph :: setSelectionColor () : Color for the node selection rectangle.  Qan.Graph.selectionWeight  /  qan :: Graph :: setSelectionWeight () : Border width of the node selection rectangle.  Qan.Graph.selectionMargin  /  qan :: Graph :: setSelectionMargin () : Margin between the node selection rectangle and the node content (selection weight is taken into account).   All theses properties could be changed dynamically.  Selection could also be disabled at node level by setting  Qan.Node.selectable  to false, node become unselectable even if global graph selection policy is not set to  NoSelection .  Current multiple selection (or single selection) is available through Qan.Graph  selectedNodes  property.  selectedNodes  is a list model, it can be used in any QML view, or iterated from C++ to read the current selection:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 // Viewing the currently selected nodes with a QML ListView:  ListView   { \n     id :   selectionListView \n     Layout . fillWidth :   true ;   Layout . fillHeight :   true \n     clip :   true       model :   graph . selectedNodes        //  ---------       spacing :   4 ;   focus :   true ;   flickableDirection   :   Flickable . VerticalFlick \n     highlightFollowsCurrentItem :   false \n     highlight :   Rectangle   { \n         x :   0 ;   y :   (   selectionListView . currentItem   !==   null   ?   selectionListView . currentItem . y   :   0   ); \n         width :   selectionListView . width ;   height :   selectionListView . currentItem . height \n         color :   lightsteelblue ;   opacity :   0.7 ;   radius :   5 \n     } \n     delegate :   Item   { \n         id :   selectedNodeDelegate \n         width :   ListView . view . width ;   height :   30 ; \n         Text   {   text :   Label:    +   itemData . label   }         //  ----- itemData is a Qan.Node, node  \n                                                         // label could be accessed directly \n         MouseArea   { \n             anchors . fill :   selectedNodeDelegate \n             onClicked :   {   selectedNodeDelegate . ListView . view . currentIndex   =   index   } \n         } \n     }  }    In C++,  selectedNodes  could be iterated directly, the current node should be tested to ensure it is non nullptr, since the underlining model is thread-safe and could have been modified from another thread:  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10      auto   graph   =   std :: make_unique qan :: Graph (); \n     for   (   auto   node   :   graph - getSelectNodes ()   )   { \n         if   (   node   !=   nullptr   ) \n             node - doWhateverYouWant (); \n     } \n     // Or better: \n     for   (   const   auto   node   :   qAsConst ( graph - getSelectNodes ())   )   { \n         if   (   node   !=   nullptr   ) \n             node - doWhateverYouWantConst (); \n     }    Example of  Qan.AbstractGraph.SelectOnClick  selection policy with multiple selection dragging inside a group:", 
            "title": "Selection"
        }, 
        {
            "location": "/topology/index.html#using-groups", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 Qan . Graph   { \n   id :   graph \n   objectName :   graph \n   anchors . fill :   parent \n\n   Component . onCompleted :   { \n     var   n1   =   graph . insertNode (   ) \n     n1 . label   =   N1 \n     var   n2   =   graph . insertNode (   ) \n     n2 . label   =   N2 \n     var   n3   =   graph . insertNode (   ) \n     n3 . label   =   N3 \n     graph . insertEdge (   n1 ,   n2   ) \n     graph . insertEdge (   n2 ,   n3   ) \n\n     var   gg   =   graph . insertGroup (); \n     gg . label   =   Group \n   }  }   // Qan.Graph: graph", 
            "title": "Using Groups"
        }, 
        {
            "location": "/topology/index.html#displaying-custom-nodes", 
            "text": "See the  custom.qml  file in  nodes  sample for more information regarding installation of specifics custom delegates for nodes and edges.  When defining custom nodes with complex geometry (ie. non rectangular), there is multiple ways to take bounding shape generation into account :    Using the default behavior for rectangular node with  complexBoundingShape  set to false (default value), bounding shape is automatically generated on node width or height change in  generateDefaultBoundingShape() .    Using dedicated code by setting  complexBoundingShape  to true and with a call to \\c setBoundingShape() from a custom onRequestUpdateBoundingShape() signal handler.    Note that signal  requestUpdateBoundingShape  won't be emitted for non complex bounding shape. Optionally, you could choose to set complexBoundingShape to false and override  generateDefaultBoundingShape()  method.", 
            "title": "Displaying Custom Nodes"
        }, 
        {
            "location": "/styles/index.html", 
            "text": "Managing Styles\n\n\nIntroduction\n\n\n\n\nDefining Styles\n\n\n\n\nThree shortcut context variables are available from QML to access default styles: \ndefaultNodeStyle\n, \ndefaultEdgeStyle\n, \ndefaultGroupStyle\n.\n\n\nQuickQanava provide a ready to use visual \nQan.StyleListView\n component for visualizing, editing styles and dragging them visually on existing graph content.", 
            "title": "Styles"
        }, 
        {
            "location": "/styles/index.html#managing-styles", 
            "text": "", 
            "title": "Managing Styles"
        }, 
        {
            "location": "/styles/index.html#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/styles/index.html#defining-styles", 
            "text": "Three shortcut context variables are available from QML to access default styles:  defaultNodeStyle ,  defaultEdgeStyle ,  defaultGroupStyle .  QuickQanava provide a ready to use visual  Qan.StyleListView  component for visualizing, editing styles and dragging them visually on existing graph content.", 
            "title": "Defining Styles"
        }, 
        {
            "location": "/utilities/index.html", 
            "text": "QuickQanava Utilities\n\n\nBottomRightResizer:\n\n\nQan.BottomRightResizer add a \"resize handler\" ont the bottom right of a target QML Item. Bottom right resizer component is automatically initialized in the QuickQanava::initialize method, it has no dependencies on QuickQanava and could be used in an isolated project just by copying its source code: fqlBotomRightRizer.h and fqlBotomRightRizer.cpp with a call to \nqmlRegisterType\n \nfql\n::\nBottomRightResizer\n \n(\n \nYourModule\n,\n \n1\n,\n \n0\n,\n \nBottomRightResizer\n \n);\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n// From c++:\n\n\nqmlRegisterType\n \nfql\n::\nBottomRightResizer\n \n(\n \nYourModule\n,\n \n1\n,\n \n0\n,\n \nBottomRightResizer\n \n);\n\n\n \n// From QML:\n\n\nimport\n \nYourModule\n \n1.0\n \nas\n \nFql\n\n\n\nItem\n \n{\n\n    \nid\n:\n \ntargetItem\n\n    \nFql\n.\nBottomRightResizer\n \n{\n \ntarget\n:\n \ntargetItem\n \n}\n\n\n}\n\n\n\n\n\n\n\nResizer not necessarilly has to be in \ntarget\n (host) sibling, \nFql\n.\nBottomRightResizer\n could be defined outside of target item hierarchy, for example to avoid corrupting the target \nchildrenRect\n property. It is however more efficient to use the resizer as a target child (most common case).\n\n\nNavigable:\n\n\nqan::Navigable", 
            "title": "Utilities"
        }, 
        {
            "location": "/utilities/index.html#quickqanava-utilities", 
            "text": "", 
            "title": "QuickQanava Utilities"
        }, 
        {
            "location": "/utilities/index.html#bottomrightresizer", 
            "text": "Qan.BottomRightResizer add a \"resize handler\" ont the bottom right of a target QML Item. Bottom right resizer component is automatically initialized in the QuickQanava::initialize method, it has no dependencies on QuickQanava and could be used in an isolated project just by copying its source code: fqlBotomRightRizer.h and fqlBotomRightRizer.cpp with a call to  qmlRegisterType   fql :: BottomRightResizer   (   YourModule ,   1 ,   0 ,   BottomRightResizer   );     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 // From c++:  qmlRegisterType   fql :: BottomRightResizer   (   YourModule ,   1 ,   0 ,   BottomRightResizer   ); \n\n  // From QML:  import   YourModule   1.0   as   Fql  Item   { \n     id :   targetItem \n     Fql . BottomRightResizer   {   target :   targetItem   }  }    Resizer not necessarilly has to be in  target  (host) sibling,  Fql . BottomRightResizer  could be defined outside of target item hierarchy, for example to avoid corrupting the target  childrenRect  property. It is however more efficient to use the resizer as a target child (most common case).", 
            "title": "BottomRightResizer:"
        }, 
        {
            "location": "/utilities/index.html#navigable", 
            "text": "qan::Navigable", 
            "title": "Navigable:"
        }, 
        {
            "location": "/advanced/index.html", 
            "text": "Advanced Use\n\n\nDefining Custom Topology\n\n\nQuickQanava topology is described using GTpo library. Topology is modelled using non visual objects modelling node (\nqan::Node\n) connected by directed edges (\nqan::Edge\n) eventually grouped in \nqan::Group\n. These non-visual objects (called primitives) are mapped to QQuickItem based visual items. Concrete QQuickItem are generated on demand using QML QQmlComponent objects. \n\n\nQuickQanava provide default delegates for all primitives, but custom delegate could be specify by providing an argument for all primitive creation functions: \nqan::Graph::insertNode()\n, \nqan::Graph::insertEdge()\n, \nqan::Graph::insertGroup()\n and their QML counterpart in \nQan.Graph\n. Simple custom delegate mapping is described in \nQuickStart\n.\n\n\nPrimitives classes could be subclassed from c++ to provide specific customization. Mapping between non-visual topology primitive and their QtQuick counterpart is managed trought static singleton factories defined in qan::Node, qan::Edge and qan::Group. Theses factories are automatically called from qan::Graph when a primitive creation request happen: a visual item with a specific style is then automatically created.\n\n\nCreation of a custom graph (MyGraph) with custom node (MyNode) and a dedicated visual item (MyNodeItem) could be achieved with the following architecture:\n\n\n\n\nFactories have to be redefined in primitive subclasses:\n\n\n\n\nstatic\n  \nQQmlComponent\n*\n      \ndelegate\n(\nQQmlEngine\n \nengine\n)\n \nnoexcept\n: Return a (usually singleton) QML component that will be used for primitive visual delegate.\n\n\nstatic\n  \nqan\n::\nNodeStyle\n*\n     \nstyle\n()\n \nnoexcept\n: Return a (usually singleton) style used as primitive default style.\n\n\n\n\nCustom content is then created from a specialized \nqan::Graph\n class:\n\n\n1\n2\n3\n4\n5\n// class MyGraph : public qan::Graph ...\n\n\n\nqan\n::\nNode\n*\n \nMyGraph\n::\ninsertMyNode\n()\n \nnoexcept\n \n{\n\n\n  \nreturn\n \ninsertNode\nMyNode\n()\n\n\n}\n\n\n\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n// In a custom MyNode.cpp defining MyNode (inheriting from qan::Node)\n\n\nQQmlComponent\n*\n  \nMyNode\n::\ndelegate\n(\nQQmlEngine\n \nengine\n)\n \nnoexcept\n\n\n{\n\n\nstatic\n \nstd\n::\nunique_ptr\nQQmlComponent\n   \nMyNode_delegate\n;\n\n    \nif\n \n(\n \n!\nMyNode_delegate\n \n)\n\n            \nCustomRectNode_delegate\n \n=\n \nstd\n::\nmake_unique\nQQmlComponent\n(\nengine\n,\n \nqrc:/MyNode.qml\n);\n\n    \nreturn\n \nCustomRectNode_delegate\n.\nget\n();\n\n\n}\n\n\n\nqan\n::\nNodeStyle\n*\n \nMyNode\n::\nstyle\n()\n \nnoexcept\n\n\n{\n\n    \nstatic\n \nstd\n::\nunique_ptr\nqan\n::\nNodeStyle\n  \nMyNode_style\n;\n\n    \nif\n \n(\n \n!\nMyNode_style\n \n)\n \n{\n\n        \nMyNode_style\n \n=\n \nstd\n::\nmake_unique\nqan\n::\nNodeStyle\n();\n\n        \nMyNode_style\n-\nsetBackColor\n(\nQColor\n(\n#ff29fc\n));\n      \n// Initialize primitive default style here\n\n    \n}\n\n    \nreturn\n \nMyNode_style\n.\nget\n();\n\n\n}\n\n\n\n\n\n\n\n\n\nSelection, visual connection and navigation will works out of the box for custom primitives (either nodes, edges or groups).\n\n\n\n\nInsertion of non Visual Content\n\n\nNon visual edge or node could be used in graph to model complex topologies or add internal non-visual logic with:\n\n\n\n\nqan\n::\nGraph\n::\ninsertNonVisualNode\n()\n: default graph \nnodeDelegate\n will no be used, custom node \ndelegate()\n may be oeither undefined or return nullptr.\n\n\nqan\n::\nGraph\n::\ninsertNonVisualEdge\n(\nsource\n,\n \ndestination\n)\n: Edge could be a regular node -\n node edge or an oriented hyper edge node -\n edge.\n\n\n\n\nObservation of Topological Modifications\n\n\nQuickQanava provide a full observation interface with the qan::Behaviour concept to react when underlying graph topology is modified. All primitives (nodes, edges or groups) could define custom behaviours to observe and react to topological changes.\n\n\n\n\nqan::NodeBehaviour\n: \n\n\n\n\nA behaviour could then be registered using: \nregisterBehaviour()\n method in \nqan::Node\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \nQuickQanava\n\n\n\nclass\n \nCustomBehaviour\n \n:\n \npublic\n \nqan\n::\nNodeBehaviour\n\n\n{\n\n  \nQ_OBJECT\n\n\npublic\n:\n\n  \nexplicit\n \nNodeBehaviour\n(\n \nQObject\n*\n \nparent\n \n=\n \nnullptr\n \n)\n \n:\n\n     \nqan\n::\nNodeBehaviour\n{\n \nCustom Behaviour\n,\n \nparent\n \n}\n \n{\n \n}\n\n  \nvirtual\n \n~\nNodeBehaviour\n()\n \n{\n \n/* Nil */\n \n}\n \n  \nNodeBehaviour\n(\n \nconst\n \nNodeBehaviour\n \n)\n \n=\n \ndelete\n;\n\n\nprotected\n:\n\n\n  \nvirtual\n \nvoid\n  \ninNodeInserted\n(\n \nqan\n::\nNode\n \ninNode\n,\n \nqan\n::\nEdge\n \nedge\n \n)\n \nnoexcept\n \noverride\n;\n\n\n  \nvirtual\n \nvoid\n  \ninNodeRemoved\n(\n \nqan\n::\nNode\n \ninNode\n,\n \nqan\n::\nEdge\n \nedge\n \n)\n \nnoexcept\n \noverride\n;\n\n\n};\n\n\n\n\n\n\n\nSuch a custom node behaviour could be installed with the following code:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n  \nqan\n::\nGraph\n \ngraph\n;\n\n  \nauto\n \nnode\n \n=\n \ngraph\n.\ninsertNode\n();\n\n\n  \nnode\n-\nattachBehaviour\n(\n \nstd\n::\nmake_unique\nCustomBehaviour\n()\n \n);\n\n\n  \n// node will now react when an in node is inserted or removed\n\n  \nauto\n \nsource\n \n=\n \ngraph\n.\ninsertNode\n();\n\n  \nauto\n \nedge\n \n=\n \ngraph\n.\ninsertEdge\n(\nsource\n,\n \nnode\n);\n   \n// CustomBehaviour::Inserted() called\n\n  \ngraph\n.\nremoveEdge\n(\nedge\n);\n                       \n// CustomBehaviour::inNodeRemoved() called\n\n\n}\n\n\n\n\n\n\n\nMethods \ninNodeInserted()\n and \ninNodeRemoved()\n are called automatically when an in node is inserted or removed on behaviour target node.\n\n\nReference documentation:\n\n\n\n\nqan::NodeBehaviour\n\n\nqan::Node::installBehaviour()", 
            "title": "Advanced use"
        }, 
        {
            "location": "/advanced/index.html#advanced-use", 
            "text": "", 
            "title": "Advanced Use"
        }, 
        {
            "location": "/advanced/index.html#defining-custom-topology", 
            "text": "QuickQanava topology is described using GTpo library. Topology is modelled using non visual objects modelling node ( qan::Node ) connected by directed edges ( qan::Edge ) eventually grouped in  qan::Group . These non-visual objects (called primitives) are mapped to QQuickItem based visual items. Concrete QQuickItem are generated on demand using QML QQmlComponent objects.   QuickQanava provide default delegates for all primitives, but custom delegate could be specify by providing an argument for all primitive creation functions:  qan::Graph::insertNode() ,  qan::Graph::insertEdge() ,  qan::Graph::insertGroup()  and their QML counterpart in  Qan.Graph . Simple custom delegate mapping is described in  QuickStart .  Primitives classes could be subclassed from c++ to provide specific customization. Mapping between non-visual topology primitive and their QtQuick counterpart is managed trought static singleton factories defined in qan::Node, qan::Edge and qan::Group. Theses factories are automatically called from qan::Graph when a primitive creation request happen: a visual item with a specific style is then automatically created.  Creation of a custom graph (MyGraph) with custom node (MyNode) and a dedicated visual item (MyNodeItem) could be achieved with the following architecture:   Factories have to be redefined in primitive subclasses:   static    QQmlComponent *        delegate ( QQmlEngine   engine )   noexcept : Return a (usually singleton) QML component that will be used for primitive visual delegate.  static    qan :: NodeStyle *       style ()   noexcept : Return a (usually singleton) style used as primitive default style.   Custom content is then created from a specialized  qan::Graph  class:  1\n2\n3\n4\n5 // class MyGraph : public qan::Graph ...  qan :: Node *   MyGraph :: insertMyNode ()   noexcept   {     return   insertNode MyNode ()  }     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 // In a custom MyNode.cpp defining MyNode (inheriting from qan::Node)  QQmlComponent *    MyNode :: delegate ( QQmlEngine   engine )   noexcept  {  static   std :: unique_ptr QQmlComponent     MyNode_delegate ; \n     if   (   ! MyNode_delegate   ) \n             CustomRectNode_delegate   =   std :: make_unique QQmlComponent ( engine ,   qrc:/MyNode.qml ); \n     return   CustomRectNode_delegate . get ();  }  qan :: NodeStyle *   MyNode :: style ()   noexcept  { \n     static   std :: unique_ptr qan :: NodeStyle    MyNode_style ; \n     if   (   ! MyNode_style   )   { \n         MyNode_style   =   std :: make_unique qan :: NodeStyle (); \n         MyNode_style - setBackColor ( QColor ( #ff29fc ));        // Initialize primitive default style here \n     } \n     return   MyNode_style . get ();  }     Selection, visual connection and navigation will works out of the box for custom primitives (either nodes, edges or groups).", 
            "title": "Defining Custom Topology"
        }, 
        {
            "location": "/advanced/index.html#insertion-of-non-visual-content", 
            "text": "Non visual edge or node could be used in graph to model complex topologies or add internal non-visual logic with:   qan :: Graph :: insertNonVisualNode () : default graph  nodeDelegate  will no be used, custom node  delegate()  may be oeither undefined or return nullptr.  qan :: Graph :: insertNonVisualEdge ( source ,   destination ) : Edge could be a regular node -  node edge or an oriented hyper edge node -  edge.", 
            "title": "Insertion of non Visual Content"
        }, 
        {
            "location": "/advanced/index.html#observation-of-topological-modifications", 
            "text": "QuickQanava provide a full observation interface with the qan::Behaviour concept to react when underlying graph topology is modified. All primitives (nodes, edges or groups) could define custom behaviours to observe and react to topological changes.   qan::NodeBehaviour :    A behaviour could then be registered using:  registerBehaviour()  method in  qan::Node .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   QuickQanava  class   CustomBehaviour   :   public   qan :: NodeBehaviour  { \n   Q_OBJECT  public : \n   explicit   NodeBehaviour (   QObject *   parent   =   nullptr   )   : \n      qan :: NodeBehaviour {   Custom Behaviour ,   parent   }   {   } \n   virtual   ~ NodeBehaviour ()   {   /* Nil */   }  \n   NodeBehaviour (   const   NodeBehaviour   )   =   delete ;  protected :     virtual   void    inNodeInserted (   qan :: Node   inNode ,   qan :: Edge   edge   )   noexcept   override ;     virtual   void    inNodeRemoved (   qan :: Node   inNode ,   qan :: Edge   edge   )   noexcept   override ;  };    Such a custom node behaviour could be installed with the following code:  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n   qan :: Graph   graph ; \n   auto   node   =   graph . insertNode ();     node - attachBehaviour (   std :: make_unique CustomBehaviour ()   );     // node will now react when an in node is inserted or removed \n   auto   source   =   graph . insertNode (); \n   auto   edge   =   graph . insertEdge ( source ,   node );     // CustomBehaviour::Inserted() called \n   graph . removeEdge ( edge );                         // CustomBehaviour::inNodeRemoved() called  }    Methods  inNodeInserted()  and  inNodeRemoved()  are called automatically when an in node is inserted or removed on behaviour target node.  Reference documentation:   qan::NodeBehaviour  qan::Node::installBehaviour()", 
            "title": "Observation of Topological Modifications"
        }, 
        {
            "location": "/samples/index.html", 
            "text": "QuickQanava Samples\n\n\nCustom Nodes: 'custom'\n\n\nDemonstrate:\n\n\n\n\nHow to define node with custom graphic content using QuickQanava node QML templates using custom delegates and \nQan.Graph.insertNode()\n calls.\n\n\nHow to use custom Canvas Qt Quick item for drawing node content with \nQan.CanvasNodeTemplate\n component (see \nDiamonNode.qml\n).\n\n\nHow to use existing Qt Quick item controls in QuickQanava nodes (see \nControlNode.qml\n).\n\n\n\n\n\n\nNavigable Area: 'navigable'\n\n\nDemonstrate use of \nqan::Navigable\n. \n\n\nGroups Management: 'groups'\n\n\nDemonstrate:\n\n\n\n\nHow to create groups of node using \nQan.Graph.insertNode()\n calls.\n\n\nHow to interact with groups by catching \nQan.Graph.groupClicked()\n and \nQan.Graph.groupRightClicked()\n signals.\n\n\n\n\n\n\nStyle Management: 'style'\n\n\n\n\nTopology Sample: 'topology'\n\n\nDemonstrate:\n\n\n\n\nHow to use \nQan.Graph.selectionPolicy\n.\n\n\nHow to use custom delegates to visualize nodes and edges in a ListView with \nQan.Graph.nodes\n and \nQan.Graph.edges\n properties.", 
            "title": "Samples"
        }, 
        {
            "location": "/samples/index.html#quickqanava-samples", 
            "text": "", 
            "title": "QuickQanava Samples"
        }, 
        {
            "location": "/samples/index.html#custom-nodes-custom", 
            "text": "Demonstrate:   How to define node with custom graphic content using QuickQanava node QML templates using custom delegates and  Qan.Graph.insertNode()  calls.  How to use custom Canvas Qt Quick item for drawing node content with  Qan.CanvasNodeTemplate  component (see  DiamonNode.qml ).  How to use existing Qt Quick item controls in QuickQanava nodes (see  ControlNode.qml ).", 
            "title": "Custom Nodes: 'custom'"
        }, 
        {
            "location": "/samples/index.html#navigable-area-navigable", 
            "text": "Demonstrate use of  qan::Navigable .", 
            "title": "Navigable Area: 'navigable'"
        }, 
        {
            "location": "/samples/index.html#groups-management-groups", 
            "text": "Demonstrate:   How to create groups of node using  Qan.Graph.insertNode()  calls.  How to interact with groups by catching  Qan.Graph.groupClicked()  and  Qan.Graph.groupRightClicked()  signals.", 
            "title": "Groups Management: 'groups'"
        }, 
        {
            "location": "/samples/index.html#style-management-style", 
            "text": "", 
            "title": "Style Management: 'style'"
        }, 
        {
            "location": "/samples/index.html#topology-sample-topology", 
            "text": "Demonstrate:   How to use  Qan.Graph.selectionPolicy .  How to use custom delegates to visualize nodes and edges in a ListView with  Qan.Graph.nodes  and  Qan.Graph.edges  properties.", 
            "title": "Topology Sample: 'topology'"
        }, 
        {
            "location": "/reference/index.html", 
            "text": "API Reference\n\n\n\n\nAPI reference index: \nhttp://www.destrat.io/quickqanava/doc", 
            "title": "API Reference"
        }, 
        {
            "location": "/reference/index.html#api-reference", 
            "text": "API reference index:  http://www.destrat.io/quickqanava/doc", 
            "title": "API Reference"
        }, 
        {
            "location": "/licence/index.html", 
            "text": "Copyright \n 2008-2017, Delia Strat\u00e9gie All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the author or Destrat.io nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "Licence"
        }
    ]
}